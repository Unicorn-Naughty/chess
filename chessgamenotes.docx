1. Если делать по ООП то мы делим наш проект на три части. (data - данные ) (main - верстка)( index - куда подключаем все)
1.1 Хз зачем но мы создаем бэк для сервака data.json, который содержит ( цвет клеток, айди клетки и фигуры)
2. Создаем функцию которая будет содежрать данные 1 ячейки и возращаем значения в функцию ( return )
Пример: 
function Square(color, id, piece) {
  return { color, id, piece };
}
3. Создаем функцию, которая содержит строчку кадвартиков function SquareRow(rowId){} и принимает как параметр свой номер
4. Создаем фукнцию которая будет в себе содержать все :
function initGame() {
  return [
    SquareRow(8),
    SquareRow(7),
    SquareRow(6),
    SquareRow(5),
    SquareRow(4),
    SquareRow(3),
    SquareRow(2),
    SquareRow(1),
  ];
}
5. В функции которая содержит строчку квадратиков SquareRow(rowId){} - мы  создаем массив(squareRow) для 1 строчки и массив букв
6. Далее прописываем условия для номера function SquareRow(rowId), которая поможет нам сделать белые и черные квадратики ( Тут будет только для 1 квадратика)
7. Для того чтобы сделать 8x8 мы делаем еще одну проверку(ту же самую как и для номера строки) для массива букв,
и уже туда прописываем заполнения массива квадратиками:
squareRow.push(Square("white", element + rowId, null));
8. Делает это как для четных и нечетных значений строк, так и для каждого из значений (index буквы) букв.
9. Помещаем полученное значение массивов в функцию SquareRow(rowId){}
10. экспортим функцию initGame в основной файл.
11. В файле main.js получаем массив по id ( который и будет содежрать наши квадратики) 
12. Создаем функцию function initGameRender(data) {}, которая будет принимать как параметр итог из п.9
13. Проходимся по основному массиву и для каждого его элемента создаем div 
(forEach), даем название и вставляем их в основной div п.11
14. Также проходимся и по элементу массива внутри массива, для каждого квадратика создаем div который будет содержать в названии square.color + 'square', так же присваиваем этому div.(id) == square.id
15. Вставляем квадратики в п.13 (appendChild)
16. Экспортим функцию из п.12 в основной файл
17. В основном файле мы делаем initGameRender(initGame()); - передаем в initGameRender как параметр initGame = data
17.1 Создаем переменную globalState = initGame()
СОЗДАЛИ ПОЛЕ
--------------------------------------------------------------------------------

18. Создаем файл (data для фигур ) pieces.js и заносим в него атрибут piece_name '' для каждой фигуры.
19. Создаем внутри него функцию с параметром текущей позиции для каждой уникальной фигуры, которая будет хранить, приме:
function blackPawn(current_postion) {
  return {
    current_postion,
    img: "pieces/black/pawn.png",
    piece_name: 'BLACK_PAWN'
  };
}
20. В файле main.js создаем функцию, которая будет обновлять фигуры на доске. (function pieceRender(data))
21. В функцию initGameRender(data), помещаем функцию, что при старте новой игры фигуры вставали на свое место.
22. В функции initGameRender(data) мы для каждой клетки задаем условия по square.id и в зависимости от square.id расставляем фигуры.
23. Экспортируем все функции из pieces.js в main.js:
import * as piece from "../Data/pieces.js"; (Чтобы обратиться к конкретной функции из экспортируемого файла нужно: piece.funcName)
24. В функции из п.20 мы  перебираем каждую строку и в каждый квадратик мы помещаем картинку:
function pieceRender(data) {
  data.forEach((row) => {
    row.forEach((square) => {
      if (square.piece) {
        const squareEl = document.getElementById(square.id);
        const piece = document.createElement("img");
        piece.src = square.piece.img;
        piece.classList.add("piece");
        squareEl.appendChild(piece);
      }
    });
  });
}
25. Создаем папку Events, где создаем global.js
26. Создаем папку с константами, где создаем constants.js
27. В файл из п.26 мы заносим переменную const ROOT_DIV = document.getElementById("root"); и подключаем ее там где используем

СОЗДАЛИ ВИЗУАЛ ДЛЯ ВСЕХ ФИГУР
--------------------------------------------------------------

28. В файле global.js из п.25 мы устанавливаем обработчик события на ROOT_DIV
29. Делаем проверку, если цель на котрую мы кликнули содержит 'img'
30. Создаем констатну:
const clickId = event.target.parentNode.id; (Ищет id у родителя)
      const flatArray = globalState.flat(); ( убирает все массивы и делает, один большой)
      const square = flatArray.find((el) => el.id == clickId); (Осуществляет поиск по массиву и осуществляет запись по найденному объекту в square )
31. Создаем функцию клика по белой пешки

31. Выполняем проверку по именни фигуры и если все хорошо запускаем функцию:
 if (square.piece.piece_name == "WHITE_PAWN") {
        whitePawnClick(square);
      }
РАБОТА С ФИГУРОЙ
      --------------------------------------------------------------------------
32. Объявляем перменную и получаем поля на которые может ходить пешка в global.js , стилизуем их в main.js + css + состояние по умолчанию false ( и переназначает текущую позицию при клики)
33. Добавляем функцию на подцветку этих полей и на убор подцветки
33. Добавляем функции на выбор фигуры по текущей позиции и смены / добавление цвета в main.js + добавляем состояние подцветки фигуры
34. Добавляем функцию хода + состояние на текущий помент
35. В функции хода деконструируем двумерный масси в обычный и добавляем проверку по которой определяем положение фигуры и куда кликнули ( при клики мы уже переназначили id фигуры( Забрали ее с клетки положения и добавили на место куда хотим ))
36. Забираем подцветку с той клетки на которой была фигура и пермещаем ее на другую
37. в GlovalEvent из п.31 мы добавляем проверку на то куда мы кликули и в конце действий мы устанавливаем сотосяния хода обртано в ноль

----------------------------------------------
38. В проверку по позиции добавляем сруб на искасок в else там же где и обычный ход +1
39. Объявляем две переменные на сруб слева и справа, использую charCodeAt (переводим на диагональ) и преобразуем в строку :
    const col1 = `${String.fromCharCode(current_pos[0].charCodeAt(0) - 1)}${
      Number(current_pos[1]) + 1
    }`;
    const col2 = `${String.fromCharCode(current_pos[0].charCodeAt(0) + 1)}${
      Number(current_pos[1]) + 1
    }`;
    